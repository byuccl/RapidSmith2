%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Section 10: Installing New Devices
%	This section provides a detailed walkthrough on how to install new devices
%	to be used in RapidSmith.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Installing New Device Files}
The device files included with the RapidSmith2 installation (listed in
\autoref{sec:supportedDevices}) have been well-tested, and are great starting
points for new users. If you are a new user, it is \emph{strongly encouraged}
that you learn RapidSmith's APIs and data structures by first implementing CAD tools on
these devices. However, RapidSmith2 also supports installing new device files
for parts not listed in \autoref{sec:supportedDevices}. This section contains
the following: (1) a description of the required intermediate files that need to be
generated from \texttt{Tincr} to support a new device, and (2) the necessary
steps to transform the intermediate files into compact device files that can be
loaded into RapidSmith2.

\subsection {XDLRC}
The \texttt{Device} data structures in RapidSmith are mainly created from XDLRC
files. XDLRC files contain a complete physical description of a Xilinx device
(including tiles, wires, sites, etc.). For older Xilinx parts (series 7 and
below), these files can be created in ISE with the \texttt{xdl} command. For
newer parts (UltraScale and above), XDLRC files can be created in Vivado using
the \texttt{Tincr} command \textit{tincr::write xdlrc}. Because XDLRC files can
grow to be hundreds of Gigabytes in size, RapidSmith compresses them into much smaller device files
(usually in the tens of Megabytes). \autoref{sec:appendixXDLRC} contains a more
detailed description of XDLRC syntax for those who are interested.

\subsection{FamilyInfo}
A \textit{familyInfo.xml} file contains useful information that is
not included in the XDLRC files for a given family of devices. Vivado currently 
supports 8 different family types: Artix7, Virtex7, Kintex7, Zynq, Kintex
UltraScale, Virtex UltraScale, Kintex UltraScale+, and Virtex UltraScale+. Only
one \textit{familyInfo.xml} file is required for each of these families (all 
devices within a family share the same family info). The remainder of this
section describes the important parts of a \textit{familyInfo.xml} file, and how
they are represented in RapidSmith2.

\begin{itemize}
  \item A list of \textbf{compatible types} for each site. Site A is said to be
  compatible with site B if the logical cells placed on site A can
  \textit{always} be placed on site B as well. For example, as shown in
  \autoref{fig:sliceCompatibility}, SLICEL sites are compatible with SLICEM
  sites. The cells placed on the SLICEL in the figure can be moved to the
  SLICEM and function indentically. SLICEM sites, however, are \textit{not}
  compatible with SLICEL sites. This is because SLICEM sites support LUT RAM
  cells, which cannot be placed on SLICEL sites.
  
  \begin{figure}[H]
    \centering
    \includegraphics[width=1\columnwidth]{compatibleSites.png}
    \caption{The same group of cells placed on a SLICEL site (left) and a SLICEM
    site (right).}
    \label{fig:sliceCompatibility}
  \end{figure}
  
  \noindent Compatible sites are important
  to site-level placers in determining where a group of cells can be placed.
  \textbf{NOTE}: In some instances of compatibility, you have to first change
  the type of the compatible site before placing cells on it. For example, a
  RAMB36 site is compatible with a RAMBFIFO36 site. However, the site type of
  the RAMBFIFO36 site \textbf{must be changed to a RAMB36} before it is
  truly compatible.
  
  \item A list of \textbf{routethrough connections} for each LUT BEL (including
  the input bel-pin and output bel-pin of the routethrough). These routethrough
  connections are turned into \texttt{Connection} objects in RapidSmith2 that
  can be used for internal site routing. Sections \ref{sec:routing} and
  \ref{sec:additionalInfo} give more information about LUT routethroughs.
  
  \item A list of \textbf{alternate types} for each site. Each physical site on
  the device has an associated default type. Some sites, however, can be
  configured to be one of many types. An example for an UltraScale
  BITSLICE\_RX\_TX site is shown in \autoref{fig:alternateTypes}. As the figure
  shows, a BITSLICE\_RX\_TX site can also be configured to be of type
  BITSLICE\_COMPONENT\_RX\_TX, BITSLICE\_RXTX\_RX, or BITSLICE\_RXTX\_TX.
  RapidSmith2 parses the alternate site information from the XML and applies it
  to the corresponding \texttt{Site} data structure. This allows users to change
  site types based on what they need.
  
  \begin{figure}[H]
    \centering
    \includegraphics[width=.8\columnwidth]{alternateTypes.png}
    \caption{Vivado GUI showing alternate types for a BITSLICE\_RX\_TX site.}
    \label{fig:alternateTypes}
  \end{figure}
  
  \item A list of \textbf{site pip corrections}. In the XDLRC files that are
  parsed into RapidSmith, site pips (or routing muxes) are not distinguished
  from the functional BELs (such as LUTs and Flip Flops) of a site. The
  Family Info XML identifies the site pips of a site and marks them as either
  a ``mux'' or a ``polarity\_selector.'' RapidSmith2 transforms these routing
  muxes into individual pips as shown in \autoref{fig:sitePipDecomposition} so
  that they are no longer represented as BELs. After the decomposition, each pip
  is a routing resource of the site.
  
  \begin{figure}[H]
    \centering
    \includegraphics[width=.5\columnwidth]{sitePipDecomposition.png}
    \caption{RapidSmith2 site pip decomposition.}
    \label{fig:sitePipDecomposition}
  \end{figure}
  
  \item A list of \textbf{pin direction corrections}. For ISE-generated XDLRC
  files, all bel-pins are given a direction of either INPUT or OUTPUT. However,
  there are several bel-pins in Xilinx devices that are actually of direction
  INOUT (bidirectional). The Family Info file marks INOUT bel-pins so that
  their direction can be corrected in RapidSmith2.
  
\end{itemize}

\subsection{Creating New Device Files for Supported Families}
\autoref{sec:supportedDevices} gives a list of currently supported
families in RapidSmith2. If the device you want to install is \textbf{not}
within a supported family, see \autoref{sec:newFamilies} for how to add support for a
new family in RapidSmith. Otherwise, a new device file can be added in two easy
steps: 

\begin {enumerate}
\item Open Vivado in Tcl mode, and execute the \texttt{Tincr} command
\textit{::tincr::write\_xdlrc}. An example command usage is given below for the
Artix7 part \textit{xc7a100tcsg324-3}.

\begin{lstlisting}[numbers=none]
[ttown523@CB461-EE09968:˜] vivado -mode tcl

****** Vivado v2014.2 (64-bit)
 **** SW Build 928826 on Thu Jun 5 17:55:10 MDT 2014
 **** IP Build 924643 on Fri May 30 09:20:16 MDT 2014
  ** Copyright 1986-2014 Xilinx, Inc. All Rights Reserved.

Vivado% ::tincr::write_xdlrc -part xc7a100tcsg324-3 -max_processes 4 -primitive_defs xc7a100tcsg324_full.xdlrc
\end{lstlisting}

\noindent The ``-max\_processes'' option is used to parallelize the operation so
that it will execute faster. If you have problems with the parallel generation
however (it can sometimes hang), then setting this option to ``1'' will
prevent the process from hanging. \textbf{NOTE}: This Tcl command can take a
very long time to run (more than 24 hours for very large devices). It is
suggested that you run it on a remote machine so that you can continue work on
your regular work machine. Also, be aware that these XDLRC files are massive. 100 GB
for the largest XDLRC files is not uncommon. Make sure you have enough space on
your hard drive before generating the XDLRC for a device.

\item Once the XDLRC creation is complete, run the device installer in
RapidSmith2 and pass the newly created XDLRC as an argument. An example command
line usage is shown below. The device installer can also be run in an IDE.

\begin{lstlisting}[numbers=none]
[ttown523@CB461-EE09968:˜] java -ea -Xmx4096m edu.byu.ece.rapidSmith.util.Installer --generate file xc7a100tcsg324_full.xdlrc
\end{lstlisting} 

\noindent The device installer parses the verbose XDLRC file, and creates
compact RapidSmith device files (Megabytes instead of Gigabytes) that represent
a Xilinx device. Notice the two JVM command line arguments used in the command
above. The first option (``-ea'') enables assertions for the code. It is important
to include this flag so that device file errors can be caught during parsing.
If you are creating a new device file for a supported family however, there
should be no errors during the installation process. The second option
(``-Xmx4096m'') sets how much memory the JVM can use while running the
installer. Since XDLRC files are so large, the memory usage of the installer can
grow very quickly. In the command above, the JVM is set to use 4 GB of memory.
If the device installer fails with an out of memory exception, you will
need to increase the number of this parameter and re-run the installer (you may
need up to 32 GB of memory here).

\end{enumerate}

\noindent Once the device installer is done executing, the compact devices files
are stored in the corresponding family directory of the RapidSmith2 ``devices''
folder. For example, the device files generated from the example part
\textit{xc7a100tcsg324-3} are stored in the ``artix7'' sub-directory. The
listing below shows the two device files that are created after the device
installer is run (the device files are bolded). The file ending in ``\_db.dat''
contains the serialized \texttt{Device} data structures for RapidSmith. The file
ending in ``\_info.dat'' contains additional serialized data (such as reverse
wire connections) that can be optionally loaded with the device.

\begin{lstlisting}[numbers=none]
[ttown523@CB461-EE09968:artix7] ls
cellLibrary.xml familyInfo.xml |\textbf{xc7a100tcsg324\_db.dat}| |\textbf{xc7a100tcsg324\_info.dat}|
\end{lstlisting} 


\subsection{Supporting New Device Families} \label{sec:newFamilies}
Vivado supports implementing FPGA designs on devices for the following families
(also called architectures):

\begin{multicols}{2}
	\begin {itemize}
	  \item \textbf{Artix7 (artix7)}
	  \item Kintex7 (kintex7)
	  \item Virtex7 (virtex7)
	  \item Zynq (zynq)
	  \item \textbf{Kintex Ultrascale (kintexu)}
	  \item Virtex Ultrascale (virtexu)
	  \item Kintex Ultrascale+ (kintexuplus)
	  \item Virtex Ultrascale+ (virtexuplus)
	  \item *Future Devices
	\end{itemize}
\end{multicols}

\noindent The name in parenthesis is the Vivado Tcl name for the family. Bolded
items are families that are currently supported in RapidSmith2 and
\texttt{Tincr}. To add RapidSmith support for another Vivado family, follow the
steps listed below.

\begin {enumerate}
  \item Create the primitive definitions for the family using VSRT. As
  described in \autoref{sec:appendixXDLRC}, the primitive definitions are the
  portion of the XDLRC file that define the components of primitive sites. Due
  to Vivado Tcl limations however, a complete set of primitive definitions
  cannot be automatically generated using Vivado Tcl commands. You will have
  to do some manual work to create the primitive definitions for the new family.
  The VSRT user guide
  {\color{blue}\url{https://github.com/byuccl/RapidSmith2/blob/ultrascale/doc/VSRTUserGuide.pdf}}
  describes in great detail how to generate a complete set of primitive
  definitions for a Vivado family of devices. Follow the guide to create the
  primitive definitions for your family. \textbf{NOTE}: Families within
  the same series (i.e. series 7, ultrascale, ultrascale+, etc.) share
  several primitive definitions. For example, many primitive defs between Kintex
  UltraScale and Virtex UltraScale families are identical. You may be able to
  reuse existing primitive definitions between families.
  
  \item Copy the primitive definitions you created in step (1) to the
   directory \textit{tincrPath/cache/family/primitiveDefs}, where ``tincrPath
   is the path to your \texttt{Tincr} installation and ``family'' is the family
   for the primitive defs you just generated (use the Vivado Tcl name if you
   need to create a new folder).
   
   \item Create the \textit{familyInfo.xml}. To do this, open Vivado in Tcl mode
   and execute the command \\
   \textit{::tincr::create\_xml\_family\_info}. An example usage of the command
   is shown below for Kintex UltraScale. 
   
\begin{lstlisting}[numbers=none]
[ttown523@CB461-EE09968:˜] vivado -mode tcl

****** Vivado v2014.2 (64-bit)
 **** SW Build 928826 on Thu Jun 5 17:55:10 MDT 2014
 **** IP Build 924643 on Fri May 30 09:20:16 MDT 2014
  ** Copyright 1986-2014 Xilinx, Inc. All Rights Reserved.

Vivado% ::tincr::create_xml_family_info familyInfo.xml kintexu addedBels.txt 
\end{lstlisting}
	
	\noindent As the listing shows, there are three arguments to the command:
	\begin{itemize}
	  \item \textbf{familyInfo.xml}: The file name to store the generated family
	  info. The file ending ``.xml" will be appended if it is not included.
	  \item \textbf{kintexu}: The Vivado family name.
	  \item \textbf{addedBels.txt}: When you are generating primitive defs
	  using VSRT (in step 1), a text file called ``addedBels.txt" is created in
	  your VSRT directory. This file contains a list of added VCC/GND BELs for
	  each family. To generate a complete Family Info file, pass this text file as
	  the third argument to the above command.
	\end{itemize}    
    
    \item Modify the generated Family Info. After step (3) is complete, a few
    hand edits are required to complete the family info file. The required hand
    edits are different between series7 and other devices.
    
    \bigbreak \noindent
	\begin{large}
	\textbf{Series7}
	\end{large}
    
    \noindent Due to complications with Vivado's Tcl interface, there are
    several hand edits that are required to complete the series7 family info
    files. This is why RapidSmith2 already provides support for series7 devices.
    However, the required manual edits are documented here in case they need to
    be regenerated for some reason. 
    
    \begin{enumerate}
      \item The first hand edit is to remove invalid alternate types. For a site
      type of IPAD, for example, Vivado's Tcl interface reports two alternate
      site types: IOB18M and IOB18S. These site types are not actually valid
      alternate types, meaning they have to be removed. The figure below
      demonstrates the actual alternate types for an IPAD site. 
      
      !!!!TODO add figure of IPAD alternate tyes in GUI.
      
      \noindent As can be seen, there are no valid alternate types. The only way
      to find invalid alternate types is to go site-by-site in the family info, select an instance of the site type in
      Vivado's device browser, and click the site type dropdown box. If there
      are any site types reported in the family info XML that are not shown in
      the GUI, they need to be removed from the XML.
      
      \item  The second hand edit is to add alternate type pin mappings. When a
      site is changed to one of its alternate types in Vivado, the site pins can
      be renamed. An example is shown in \autoref{fig:alternatePinRename} for an
      IDELAYE3 site that has been changed to type ISERDESE2.
      
      TODO: ADD FIGURE HERE SHOWING PIN RENAMINGS
      
      Unfortunatly the pin renamings cannot be automatically extracted from
      Vivado's Tcl interface, and so must be added manually. The XML example
      below shows how to add pin renamings to the Family Info.

\begin{lstlisting}[numbers=none]
    <site_type>
      <name>ILOGICE3</name>
      <alternatives>
        <alternative>
          <name>ILOGICE2</name>
          |\textbf{<pinmaps>}|
          |\textbf{</pinmaps>}|
        </alternative>
        <alternative>
          <name>ISERDESE2</name>
          |\textbf{<pinmaps>}|
	        |\textbf{<pin>}|
	          |\textbf{<name>RST</name>}|
	          |\textbf{<map>SR</map>}|
	        |\textbf{</pin>}|
          |\textbf{</pinmaps>}|
        </alternative>
      </alternatives>
\end{lstlisting}
      
      \noindent The XML ``pinmaps'' tag is included for all alternate types in
      the initial XML file created from \textit{create\_xml\_family\_info}, all
      you need to do is fill in the pin mappings. To determine the actual pin
      mappings, you need to open two instances of the Vivado GUI. For each site
      in the Family Info, load the default type in one Vivado instance, load the
	  the alternate type in the other instance, and visibly check what pins are
	  renamed in the alternate type (as demonstrated in
	  \autoref{fig:alternatePinRename}). This process can be tedious, but there is
	  currently no other solution. \textbf{NOTE}: Steps (a) and (b) are generally
	  done at the same time for each site.
	  
	  \item The third hand edit is to remove invalid mux corrections. In some
	  cases, BELs might be incorrectly tagged as ``routing muxes'' or ``polarity selectors'' even though they are
	  not. This issue has mostly been fixed, but it is still good practice to
	  examine all of the mux corrections in the Family Info and verify that they
	  are correct.
	  
	  \item The final hand edit is to add missing compatible types. Some compatible
	  types can be automatically generated from Vivado, but not all. This means
	  that the missing compatible types must be added manually. The next section
	  (``Other Devices'') describes in more detail how to add compatible types to the Family Info.
	  
    \end{enumerate}
    
    \bigbreak \noindent
	\begin{large}
	\textbf{Other Devices}
	\end{large}
	  	
  	\noindent UltraScale and later devices require only one hand edit: adding 
  	compatible types that are missing (although most compatible types can be
  	determined automatically). The XML listings below show the compatible types
  	that were missing for Kintex UltraScale (which need to be added manually).

\begin{lstlisting}[numbers=none]
    <site_type>
      <name>SLICEL</name>
      <is_slice/>
      |\textbf{<compatible\_types>}|
        |\textbf{<compatible\_type>SLICEM</compatible\_type>}|
      |\textbf{</compatible\_types>}|
\end{lstlisting}  

\begin{lstlisting}[numbers=none]
    <site_type>
      <name>HRIO</name> 
      <is_iob/>
      |\textbf{<compatible\_types>}|
        |\textbf{<compatible\_type>HPIOB</compatible\_type>}|
      |\textbf{</compatible\_types>}|
\end{lstlisting} 
   
	\noindent For other device families, you may have to add additional compatible
	sites. It is up to you to determine what compatible sites need to be added
	through experimentation.
  
  	\noindent 
\end{enumerate}
 